# webhook_sender.py - This script monitors the chunk_data folder and sends files

import os
import sys
import time
import requests
import threading # Import threading for potential future use or context, though not strictly needed for simple polling

# --- Configuration ---

# The directory where the chunked CSV files are generated by test_chunks.py
CHUNK_DATA_DIRECTORY = "chunk_data"

# IMPORTANT: Get your n8n Webhook URL and paste it here.
# This URL will look something like: https://your-n8n-instance.n8n.cloud/webhook-test/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
# Be cautious with sharing this URL!
N8N_WEBHOOK_URL = "https://metasage-ai.app.n8n.cloud/webhook-test/79975fb8-b60c-4261-a447-77ab1df4d99c" # <--- REPLACE WITH YOUR ACTUAL WEBHOOK URL
# Make sure your n8n workflow is set up with a Webhook node listening for POST requests.

# Polling interval to check the CHUNK_DATA_DIRECTORY for new files (in seconds)
POLLING_INTERVAL_SECONDS = 2

# How long to wait and check file size stability before assuming a file is complete (in seconds)
FILE_COMPLETION_CHECK_TIME = 2 # Wait for size to be stable for this duration

# --- Script Logic ---

def send_file_webhook(file_path, webhook_url):
    """Reads the content of a file and sends it as a POST request to the webhook URL."""
    if not webhook_url:
        print(f"Error: Webhook URL not configured to send '{file_path}'.", file=sys.stderr)
        return False # Indicate failure

    if not os.path.exists(file_path):
        print(f"Warning: File not found to send via webhook: {file_path}", file=sys.stderr)
        return False # Indicate failure

    try:
        # Prepare the file for sending. 'files' parameter in requests handles file-like objects.
        # The key ('file' in this case) is the name of the file parameter expected by the server/webhook.
        # Reading in binary mode 'rb' is standard for sending files.
        # Using timeout is highly recommended for network requests
        request_timeout = 30 # seconds - Give it enough time for potentially large files

        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Attempting to send chunk file '{os.path.basename(file_path)}' to webhook...")

        with open(file_path, 'rb') as f:
            # The 'file' key here is the name of the form field n8n expects for the file upload.
            # 'text/csv' is the MIME type.
            files = {'file': (os.path.basename(file_path), f, 'text/csv')}

            response = requests.post(webhook_url, files=files, timeout=request_timeout)

            # Check the response
            if response.status_code >= 200 and response.status_code < 300:
                print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Successfully sent chunk '{os.path.basename(file_path)}'. Webhook responded: {response.status_code}")
                return True # Indicate success
            else:
                print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Warning: Webhook request failed for '{os.path.basename(file_path)}'. Status Code: {response.status_code}, Response: {response.text}", file=sys.stderr)
                return False # Indicate failure

    except requests.exceptions.Timeout:
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Error: Webhook request timed out for '{os.path.basename(file_path)}'.", file=sys.stderr)
        return False # Indicate failure
    except requests.exceptions.RequestException as e:
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Error sending chunk '{os.path.basename(file_path)}' to webhook: {e}", file=sys.stderr)
        return False # Indicate failure
    except Exception as e:
         print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] An unexpected error occurred while preparing/sending webhook for '{os.path.basename(file_path)}': {e}", file=sys.stderr)
         return False # Indicate failure

def is_file_finished_writing(file_path, check_duration):
    """
    Heuristically checks if a file appears to have finished writing by
    monitoring its size for a short duration.
    """
    if not os.path.exists(file_path):
        return False # File disappeared

    try:
        initial_size = os.path.getsize(file_path)
        if initial_size == 0:
            return False # Still empty, likely not ready

        time.sleep(check_duration) # Wait for the check duration

        if not os.path.exists(file_path):
             return False # File disappeared during sleep

        final_size = os.path.getsize(file_path)

        # File size hasn't changed during the check duration, assume complete
        return initial_size == final_size

    except FileNotFoundError:
        return False # File disappeared during check
    except Exception as e:
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Error checking file completion for '{os.path.basename(file_path)}': {e}", file=sys.stderr)
        return False # Assume not complete on error

def monitor_directory_and_send(directory, webhook_url, polling_interval, completion_check_duration):
    """
    Monitors a directory for new CSV files and sends them via webhook
    once they appear to be fully written.
    """
    sent_files = set() # Keep track of files we've already sent

    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Starting monitoring of directory: '{directory}'")
    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Polling interval: {polling_interval} seconds")
    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] File completion check duration: {completion_check_duration} seconds")
    print("-" * 30)
    print("Press Ctrl+C to stop monitoring.")
    print("-" * 30)


    # Load previously sent files list? (Optional, but good for restarts)
    # You could save the 'sent_files' set to a file periodically.
    # For this example, we start fresh on each run.

    try:
        while True:
            if os.path.exists(directory):
                try:
                    # List all files in the directory
                    files_in_dir = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]

                    # Filter for potential CSV chunk files that haven't been sent yet
                    candidate_files = [
                        f for f in files_in_dir
                        if f.lower().endswith('.csv') and f not in sent_files
                        # Optional: Add more specific pattern matching if needed, e.g., f.startswith('traffic_chunked_')
                    ]

                    if candidate_files:
                        # Process candidate files, prioritizing older ones if possible
                        for filename in sorted(candidate_files):
                            file_path = os.path.join(directory, filename)

                            # Check if the file appears to be fully written
                            if is_file_finished_writing(file_path, completion_check_duration):
                                print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Detected completed file: '{filename}'. Attempting to send...")
                                # Attempt to send the file
                                if send_file_webhook(file_path, webhook_url):
                                    sent_files.add(filename) # Mark as sent only on successful send
                                    # Optional: Delete the file after successful send
                                    # try:
                                    #     os.remove(file_path)
                                    #     print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Deleted local file after successful send: {filename}")
                                    # except OSError as e:
                                    #      print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Warning: Could not delete file {filename}: {e}", file=sys.stderr)
                            else:
                                # print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] File '{filename}' not yet complete. Skipping for now.") # Too verbose
                                pass # File is still being written, check again later

                    # print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Checked directory. Found {len(files_in_dir)} files, {len(sent_files)} already sent. Sleeping...") # Too verbose


                except FileNotFoundError:
                    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Warning: Monitored directory '{directory}' not found.", file=sys.stderr)
                    # Decide what to do if directory disappears - maybe just keep trying?
                    # If test_chunks.py stops and doesn't remove the dir, it will eventually find remaining files.
                    pass # Keep trying
                except Exception as e:
                    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Error during directory monitoring: {e}", file=sys.stderr)


            else:
                 # Directory does not exist
                 print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Monitored directory '{directory}' does not exist. Waiting for it to be created...", file=sys.stderr)
                 # If test_chunks.py hasn't started yet, the directory won't exist.
                 # Keep waiting/polling until it appears.

            # Wait before the next directory check cycle
            time.sleep(polling_interval)

    except KeyboardInterrupt:
        print(f"\n[{time.strftime('%Y-%m-%d %H:%M:%S')}] Ctrl+C detected. Stopping monitoring.")
    except Exception as e:
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] An unexpected error occurred during monitoring loop: {e}", file=sys.stderr)

    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Monitoring script finished.")


if __name__ == "__main__":
    # --- IMPORTANT REMINDER ---
    print("--- Webhook Sender Script ---")
    print(f"This script monitors the '{CHUNK_DATA_DIRECTORY}' directory for new CSV files.")
    print(f"It will send new files to the webhook URL: {N8N_WEBHOOK_URL}")
    print("Ensure 'requests' is installed (`pip install requests`).")
    print("Ensure the directory and webhook URL are correctly configured.")
    print("-" * 30)

    # Add a brief pause
    time.sleep(1)

    # --- Input Validation ---
    if N8N_WEBHOOK_URL == "YOUR_N8N_WEBHOOK_URL_HERE" or not N8N_WEBHOOK_URL.startswith('http'):
         print("\nERROR: Please set a valid N8N_WEBHOOK_URL in the script.", file=sys.stderr)
         sys.exit(1)

    try:
        import requests
    except ImportError:
        print("\nERROR: 'requests' library is not installed. Install it with 'pip install requests'.", file=sys.stderr)
        sys.exit(1)


    # --- Start Monitoring ---
    # This script runs indefinitely until stopped by Ctrl+C or an unhandled error
    monitor_directory_and_send(
        directory=CHUNK_DATA_DIRECTORY,
        webhook_url=N8N_WEBHOOK_URL,
        polling_interval=POLLING_INTERVAL_SECONDS,
        completion_check_duration=FILE_COMPLETION_CHECK_TIME
    )

    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] --- Script Finished ---")